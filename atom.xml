<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梦之所在，心之所往</title>
  
  <subtitle>Sometimes just a semicolon ， making the difference between success and failure</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-29T16:01:30.667Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>魏澳</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap</title>
    <link href="http://yoursite.com/2019/11/27/HashMap/"/>
    <id>http://yoursite.com/2019/11/27/HashMap/</id>
    <published>2019-11-27T14:44:29.000Z</published>
    <updated>2019-11-29T16:01:30.667Z</updated>
    
    <content type="html"><![CDATA[<p><img src="data:image/jpeg;base64,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" alt=""></p><blockquote><p>进入这篇文章之前，我想清楚的说一说怎么去理解<code>HashMap</code>源码。它先是使用的<code>hash</code>算法，那么哈希算法需要注意的那就是怎么<code>hash</code>，怎么减少冲突，怎么避免冲突。然后是<code>Map</code>,<code>Map</code>是存储这些<code>&lt;K,V&gt;结构</code>的<code>Entity</code>，那么<code>HashMap</code>需要注意的就是<code>HashMap</code>的初始化过程，什么时候进行数组（桶）扩容等等</p></blockquote><h1 id="HashMap源码"><a href="#HashMap源码" class="headerlink" title="HashMap源码"></a>HashMap源码</h1><h2 id="构造和初始化"><a href="#构造和初始化" class="headerlink" title="构造和初始化"></a>构造和初始化</h2><p>要深入了解<code>HashMap</code>就必须先了解它的这几个比较重要属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//节点，就是Entity</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//同来记录使用过的那些键值对</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Map中k，v的对数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//threshold（threshold=capacity*loadFactor）是一个阈值，是触发resize的一个重要条件</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">//负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p><code>HashMap</code>有四种构造方法，如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">自定义初始容量和负载因子</span></span><br><span class="line"><span class="comment">代码解释：</span></span><br><span class="line"><span class="comment">先进行判断传进来的初始容量是否合法，如果初始化容量超出了最大容量范围，就将给它设置最大容量的值</span></span><br><span class="line"><span class="comment">再判断负载因子是否合法，如果是合法的就将次负载因子正确的初始化。  threshold（threshold=capacity*loadFactor）是一个阈值，当HashMap的size大于这个阈值，就会进行 resize</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">//默认初始容量16  </span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//最大容量是1&lt;&lt;30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//默认的负载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//树形化的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在剪枝的时候取消树形化的阈值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小树形化容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">//tabelSizeFor(int cap)方法是为了对于一些不是2的幂次方的数求出大于initialCapacity的最小的2的幂次方数，然后赋值给threshold。值得注意的是，我看了看JDK8以前的代码，这块是没有这个tableSizeFor操作，而是直接将initialCapacity赋值给threshold。</span></span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    默认容量16，负载因子0.75</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对于上面说到过的<code>tableSizeFor</code>方法，可以来看看是怎么实现的，很精致的一段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 提出问题：</span></span><br><span class="line"><span class="comment"> 1.为什么cap-1</span></span><br><span class="line"><span class="comment"> 2.为什么要用五个移位或操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> 解决问题：</span></span><br><span class="line"><span class="comment"> 先说第二个问题</span></span><br><span class="line"><span class="comment"> 以5为例，我们都知道一个int值是4个字节，也就是32为</span></span><br><span class="line"><span class="comment"> 0101</span></span><br><span class="line"><span class="comment"> 0010 -&gt; 0111</span></span><br><span class="line"><span class="comment">         0000 -&gt; 0111 </span></span><br><span class="line"><span class="comment">         .....</span></span><br><span class="line"><span class="comment">         移位或的结果是0111（32为数前面的0此处省略）</span></span><br><span class="line"><span class="comment">         </span></span><br><span class="line"><span class="comment">  因此我们可以看出来这些移位或运算都是为了使得最小的大于这个数的2的幂次方这个数的后面所有位都变为1，然后我们在n在合理范围内+1就可以得到我们想要得到的值了。</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">  现在来说第一个问题，为什么是cap-1呢。我们可以试图想一想，如果输入这个值本来就是2的幂次方，那么这么一系列操作之后我们会惊奇的发现，求出来的值会是我们想要求出的值的2倍。这就是为什么先对cap-1</span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="comment">//如果n&lt;0，就返回1,n&gt;=0，如果n&gt;=最大容量，就返回最大容量，否则就返回n+1</span></span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*输出</span></span><br><span class="line"><span class="comment">    tableSizeFor(5)=8</span></span><br><span class="line"><span class="comment">    tableSizeFor(8)=8</span></span><br><span class="line"><span class="comment">    tableSizeFor(9)=16</span></span><br><span class="line"><span class="comment">    */</span></span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"tableSizeFor(5)="</span>+tableSizeFor(<span class="number">5</span>));</span><br><span class="line">        System.out.println(<span class="string">"tableSizeFor(8)="</span>+tableSizeFor(<span class="number">8</span>));</span><br><span class="line">        System.out.println(<span class="string">"tableSizeFor(9)="</span>+tableSizeFor(<span class="number">9</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">正常情况</span><br><span class="line">tableSizeFor(<span class="number">5</span>)=<span class="number">8</span></span><br><span class="line">tableSizeFor(<span class="number">8</span>)=<span class="number">8</span></span><br><span class="line">tableSizeFor(<span class="number">9</span>)=<span class="number">16</span></span><br><span class="line"></span><br><span class="line">注释掉cap-<span class="number">1</span>并进行相应替换后的情况</span><br><span class="line">tableSizeFor(<span class="number">5</span>)=<span class="number">8</span></span><br><span class="line">tableSizeFor(<span class="number">8</span>)=<span class="number">16</span></span><br><span class="line">tableSizeFor(<span class="number">9</span>)=<span class="number">16</span></span><br></pre></td></tr></table></figure><h2 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h2><p>说put前，肯定要先说说hash方法，在1.8中的hash和1.7中不同，比1.7中右移变少（也就是位扰动），有一部分是因为在1.8中加入了红黑树在同一index下，保证了查找效率，不会因为散列集中引起性能大幅度下降。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//hash就是hash(k),onlyIfAbsent如果是true的话，就是如果key相同的话不进行覆盖，evict如果是false的话就表示初始化</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">     <span class="comment">//1.判断当前hashtable是否为空，如果为空就进行初始化 resize方法既能用于初始化，又能用于扩容</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">         n = (tab = resize()).length;</span><br><span class="line">     <span class="comment">//2.根据（n-1）&amp;hash得到index，判断index的位置是否为空（链表头或树根），如果是空就new一个Node并放到这个位置</span></span><br><span class="line">     <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">         tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">     <span class="comment">//3.如果index这个位置不为空</span></span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">         Node&lt;K,V&gt; e; K k;</span><br><span class="line">         <span class="comment">//p就是当前index下对应的Node节点</span></span><br><span class="line">         <span class="comment">//3-1.（如果当前桶放的是链表）如果p的key对应的值和准备要方进来的key的值是相同的，就把这个值（OldNode）记下来（记为e）</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">             ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             e = p;</span><br><span class="line">         <span class="comment">//3-2.（如果当前桶放的是树）如果是树节点，就调用putTreeVal，在下面会说</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">             e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">         <span class="comment">//3-3.如果不是覆盖操作，那就进行遍历链表（因为在3-2中已经排除了是树），找到链表最后的一个节点进行尾插，并用binCount记录当前正在遍历的链表此刻的长度。</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                 <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                     <span class="comment">//到达链表尾部的话就进行尾插</span></span><br><span class="line">                     p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                     <span class="comment">//如果binCount=7（TREEIFY_THRESHOLD-1）就说已经达到树形化的一个条件了（另一个条件是table.length&gt;=MIN_TREEIFY_CAPACITY,默认为64），因为现在未加入新节点都已经是7了，因此肯定是会到达树化的阈值，因此会进入treeifyBin(tab, hash)方法。</span></span><br><span class="line">                     <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) </span><br><span class="line">                         treeifyBin(tab, hash);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">//如果未到达尾部，就对hash值进行比对，如果hash值相同并且key也是相同的，那就说明找到要替换的节点（就可以break了）</span></span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 </span><br><span class="line">                 <span class="comment">//没找到要替换的节点就替换以便于通过p访问下一个Node（循环要素）</span></span><br><span class="line">                 p = e;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//如果e！=null就说明有需要替换的值（如果遍历到链表尾部，e=null）</span></span><br><span class="line">         <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">             <span class="comment">//oldValue拿出来准备返回</span></span><br><span class="line">             V oldValue = e.value;</span><br><span class="line">             <span class="comment">//onlyIfAbsent默认false（有相同就替换）或者以前的值是null就进行替换</span></span><br><span class="line">             <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                 e.value = value;</span><br><span class="line">             <span class="comment">//空方法</span></span><br><span class="line">             afterNodeAccess(e);</span><br><span class="line">             <span class="comment">//返回被替换的值</span></span><br><span class="line">             <span class="keyword">return</span> oldValue;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">//如果能执行到此处的话，说明是添加了一个节点而不是修改了一个节点，因此++modCount</span></span><br><span class="line">     ++modCount;</span><br><span class="line">     <span class="comment">//对size值进行++操作，如果size&gt;threshold，就要进行扩容</span></span><br><span class="line">     <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">         resize();</span><br><span class="line">     <span class="comment">//空方法</span></span><br><span class="line">     afterNodeInsertion(evict);</span><br><span class="line">     <span class="comment">//不是更新进返回null</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//new一个Node节点</span></span><br><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Node&lt;&gt;(hash, key, value, next);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//没有任何东西，这些空方法并且是afterxx都可作为回调方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//给红黑树里添加Node</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</span><br><span class="line">            Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//取树根，如果当前Node的parent！=null，说明不是根，需要循环找根。如果parent==null说明就是根</span></span><br><span class="line">            TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">//从根开始遍历这棵树</span></span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> dir, ph; K pk;</span><br><span class="line">                <span class="comment">//根据哈希判断去左还是去右</span></span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    dir = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    dir = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果key相等就返回p，说明找到替换的节点了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="comment">//如果hash相等，但是key不相等</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                          (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!searched) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; q, ch;</span><br><span class="line">                        searched = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="comment">//如果从当前hash相同的节点的子树中找到key相同的就返回</span></span><br><span class="line">                        <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</span><br><span class="line">                            ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                             (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</span><br><span class="line">                            <span class="keyword">return</span> q;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//当哈希值相同并且不可比较</span></span><br><span class="line">                    dir = tieBreakOrder(k, pk);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果hash不相等，根据上边的dir进行选路</span></span><br><span class="line">                TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; xpn = xp.next;</span><br><span class="line">                    TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</span><br><span class="line">                    <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                        xp.left = x;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        xp.right = x;</span><br><span class="line">                    xp.next = x;</span><br><span class="line">                    x.parent = x.prev = xp;</span><br><span class="line">                    <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)xpn).prev = x;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//插入后并且进行树的平衡</span></span><br><span class="line">                    moveRootToFront(tab, balanceInsertion(root, x));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环找根</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果table==null就进行初始化，table.length&lt;MIN_TREEIFY_CAPACITY=64,就进行桶的扩容而不是进行树化</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> hash)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">           resize();</span><br><span class="line">       <span class="comment">//如果满足上面集合条件就遍历并进行树化</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> ((e = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">           <span class="keyword">do</span> &#123;</span><br><span class="line">               TreeNode&lt;K,V&gt; p = replacementTreeNode(e, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">if</span> (tl == <span class="keyword">null</span>)</span><br><span class="line">                   hd = p;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                   p.prev = tl;</span><br><span class="line">                   tl.next = p;</span><br><span class="line">               &#125;</span><br><span class="line">               tl = p;</span><br><span class="line">           &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> ((tab[index] = hd) != <span class="keyword">null</span>)</span><br><span class="line">               hd.treeify(tab);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//通过key进行查找</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//在传入getNode方法时先对key进行hash</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//如果table！=null，并且hash对应的桶的位置也要有值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果key可以被直接找到就返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果first存在next</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是树型，就调用getTreeNode去找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果是链表就去遍历</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到就返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//根据key移除</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//传入hash，key，value=null，machValue=false，movable=true</span></span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果matchable=true，就表示表示只有key，value同时相等时才删除   movale如果为false就表示删除节点的时候不移动其他节点</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">//如果table不为null并且次hash对应的数组节点上有值</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="comment">//过程很简单，就是找到这个节点并记录下来</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node！=null并通过传进来的matchValue来选择需不需要对value进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">//如果是树节点，就调用removetreeNode</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="comment">//如果是表头就让下一个作为表头</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="comment">//如果不是表头</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">//删除成功就说明修改了</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//修改size</span></span><br><span class="line">            --size;</span><br><span class="line">            <span class="comment">//空方法</span></span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//没找到就返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="comment">//如果oldTable为null，就为0，否则就是oldTable.length</span></span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果不是空table</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果为空table但oldThr&gt;0，那么初始容量就使用以前的阈值</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) </span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="comment">//如果threshold并且threshold被默认赋值为0（也就是没有进行table的初始化），那么就进行table初始化</span></span><br><span class="line">        <span class="keyword">else</span> &#123;               </span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//上一步对table初始化的时候并没有对threshold进行初始化，因此对它赋值</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">            Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">//对oldTab进行遍历并把值移动到newTab，一个桶一个桶的进行遍历</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        <span class="comment">//使用e.hash对newCap-1进行与，而不是oldCap</span></span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//如果是棵树，可以考虑对它进行剪枝操作</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//如果是链表，就对链表进行复制</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//判断e需不需要进行移动，因为容量变了，为了保证正确性（如果是小于oldCap的数，结果就会为0）</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//徐娅哦移动</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//进行尾插（1.7是头插）</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//需要移动的偏移量是oldCap</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">//树的修剪</span></span><br><span class="line"><span class="comment">//index表示修剪的开始，bit代表修剪的位数</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index, <span class="keyword">int</span> bit)</span> </span>&#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; b = <span class="keyword">this</span>;</span><br><span class="line">            <span class="comment">// Relink into lo and hi lists, preserving order</span></span><br><span class="line">            <span class="comment">//减为两棵树</span></span><br><span class="line">            TreeNode&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">            TreeNode&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; e = b, next; e != <span class="keyword">null</span>; e = next) &#123;</span><br><span class="line">                next = (TreeNode&lt;K,V&gt;)e.next;</span><br><span class="line">                e.next = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//如果e.hash &amp; bit就放到LTree</span></span><br><span class="line">                <span class="keyword">if</span> ((e.hash &amp; bit) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                        loHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        loTail.next = e;</span><br><span class="line">                    loTail = e;</span><br><span class="line">                    ++lc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//否则就放到HTree</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                        hiHead = e;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        hiTail.next = e;</span><br><span class="line">                    hiTail = e;</span><br><span class="line">                    ++hc;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//元素个数小于等于6就会还原为链表</span></span><br><span class="line">            <span class="keyword">if</span> (loHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index] = loHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index] = loHead;</span><br><span class="line">                    <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) <span class="comment">// (else is already treeified)</span></span><br><span class="line">                        loHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//给index+bit（也就是原数组容量）就是HTree放的位置（也就是放在了修剪范围之外）</span></span><br><span class="line">            <span class="keyword">if</span> (hiHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">                    tab[index + bit] = hiHead.untreeify(map);</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    tab[index + bit] = hiHead;</span><br><span class="line">                    <span class="keyword">if</span> (loHead != <span class="keyword">null</span>)</span><br><span class="line">                        hiHead.treeify(tab);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><blockquote><p> 读到这，我相信HashMap里面比较难理解的代码都基本掌握了！</p></blockquote><h2 id="和HashTable的对比"><a href="#和HashTable的对比" class="headerlink" title="和HashTable的对比"></a>和HashTable的对比</h2><ul><li><p><code>HashTable</code>默认容量是11。而<code>HashMap</code>是16</p></li><li><p><code>HashTable</code>是直接使用key的hashCode(key.hashCode())作为hash值，<code>HashMap</code>内部使用hash(Object key)进行位扰动对key的hashCode进行扰动后作为hash值。</p></li><li><p><code>HashTable</code>取哈希桶下标是直接用模运算%,并且也没有容量必须是2的幂次方要求</p></li><li><p><code>Hashtable</code>是<code>Dictionary</code>的子类同时也实现了Map接口，<code>HashMap</code>是对Map接口的一个实现</p></li><li><p><code>HashTable</code>是线程安全的，且不允许key、value是null,<code>HashMap</code>可以有空的key</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAkGBxITEhUTExMWFRUVFxgXFxgXGBgXGBgYGhcXFxcdHhgYHSggGBolHRYXITEhJSkrLi4u
      
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="源码" scheme="http://yoursite.com/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="http://yoursite.com/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>面试题1</title>
    <link href="http://yoursite.com/2019/11/27/%E9%9D%A2%E8%AF%95%E9%A2%981/"/>
    <id>http://yoursite.com/2019/11/27/%E9%9D%A2%E8%AF%95%E9%A2%981/</id>
    <published>2019-11-27T01:33:00.000Z</published>
    <updated>2019-11-27T14:20:09.573Z</updated>
    
    <content type="html"><![CDATA[<h3 id="final-finally-finilize的区别"><a href="#final-finally-finilize的区别" class="headerlink" title="final finally finilize的区别"></a>final finally finilize的区别</h3><p><a href="[https://github.com/wrail/BaseJava/blob/master/Java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89.md](https://github.com/wrail/BaseJava/blob/master/Java核心基础（一）.md)">链接</a></p><ul><li>final可以修饰变量，方法和类。它修饰的变量不能被改变，修饰的方法不能被重写，修饰的类不能被继承。</li><li>finally是一种保证代码一定被执行的机制，可以使用finally来关闭资源等</li><li>finalize是Object类的一个方法，与垃圾回收相关，在新版本JDK中已经不建议使用了，有替代的方法java.lang.ref.Cleaner</li></ul><h3 id="jvm内存结构，类加载机制，双亲委派模型，垃圾回收算法"><a href="#jvm内存结构，类加载机制，双亲委派模型，垃圾回收算法" class="headerlink" title="jvm内存结构，类加载机制，双亲委派模型，垃圾回收算法"></a>jvm内存结构，类加载机制，双亲委派模型，垃圾回收算法</h3><h4 id="JVM内存结构："><a href="#JVM内存结构：" class="headerlink" title="JVM内存结构："></a>JVM内存结构：</h4><p>JVM=类加载器（class loader）+执行引擎（execution engine）+运行时数据区（runtime data area）</p><p>运行时数据区可以分为：方法区，堆，本地方法栈，虚拟机栈，程序计数器，前两个是线程公有的，后三个是线程私有的。</p><ul><li>方法区里一般放的都是常量（常量池中）</li><li>堆里面主要放的是对象，数组，因此也是垃圾收集的主要区域</li><li>本地方法栈为Native方法服务，虚拟机栈为字节码服务，发挥的作用和虚拟机栈是很相似的</li><li>虚拟机栈是Java程序执行的重要场所，每一个方法在执行的时候都会创建一个栈帧被压进来，一个方法的调用到结束就对应的是它的进栈和出栈。栈帧里面主要有局部变量表，操作数栈，方法出口，动态链接等</li><li>程序计数器可以看作是字节码执行过程中的行号指示器，和微机原理里面的pc作用是相似的</li></ul><h4 id="类加载机制和双亲委派："><a href="#类加载机制和双亲委派：" class="headerlink" title="类加载机制和双亲委派："></a>类加载机制和双亲委派：</h4><p><a href="[https://github.com/wrail/JVM/blob/master/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89.md](https://github.com/wrail/JVM/blob/master/深入理解JVM学习笔记（四）.md)">类加载</a></p><p>类的生命周期：加载，链接（验证(主要包括文件格式验证，元数据验证，字节码验证，符号引用验证)，准备，解析），初始化（有且只有<strong>首次次主动使用</strong>的时候才会初始化），使用，卸载。</p><p><a href="https://blog.csdn.net/javazejian/article/details/73413292" target="_blank" rel="noopener">类加载器和双亲委派机制</a></p><p>类加载器分为</p><ul><li><p>启动类加载器负责加载<JAVA_HOME>\lib目录的或者是被-Xbootclasspath指定路径中的</p></li><li><p>扩展类加载器用来加载<JAVA_HOME>\lib\ext,或java.ext.dirs系统变量指定的路径中的所有类库</p></li><li><p>应用类加载器一般是程序中默认的加载器（getSystemClassLoader返回值就是它，因此也称为系统类加载器），用来加载用户类路径（classpath）指定的类库。</p></li><li><p>自定义类加载器</p><blockquote><p> 只有启动类加载器是用c++写的，是虚拟机的一部分，其余是Java写的，在虚拟机外部（继承于java.lang.ClassLoader）。</p></blockquote></li></ul><p>双亲委派的基本过程：一个类加载器收到加载请求，首先会将这个请求委派给父类加载器，每层都是如此，当父类加载器反馈无法加载，子加载器才会尝试去加载。</p><p>双亲委派的好处：Java类随它的加载器而具有了优先级层次关系，避免了类加载引起应用程序的混乱。（比如我们自己写一个rt.jar中的重名的类，它永远不会被加载）</p><h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul><li><p>标记清除</p><ul><li>标记阶段：标记从根结点开始的所有可达对象</li><li>清除阶段：清除未被标记的对象</li></ul><p>不足：标记和清除的效率都不高，并且标记清除完会产生大量不连续的内存碎片（影响较大的对象的空间分配）</p></li><li><p>复制算法：使用两块大小绝对相等的空间，每次只使用一块</p><ul><li>每次使用其中一块，当这块内存用完，把存货的对象复制到另一块，然后将当前这块清空</li></ul><p>优点是实现简单，运行高效</p><p>缺点是浪费空间</p><blockquote><p>研究表明98%对象都是朝生夕死的，不需要对内存1：1划分，而是将内存分为新生代Eden（80%）+Survivor1（10%）+Survivor2（10%），如果超过10%的对象存活，就意味着Survivor区空间不够，就需要另外一块Survivor为当前Survivor区做担保，使得这些放不下的对象进入老年代。普通的对象进入老年代的话年龄需要到达15（也就是15次gc中存活下来的）。大对象是直接进入老年区（大对象需要很长的连续地址，直接进入老年区目的是避免对象在Eden和Survivor区来回复制，影响效率）</p></blockquote></li><li><p>标记整理</p><ul><li>标记过程和标记清除的标记是相同的</li><li>整理：让所有存活的对象向一端移动，然后清理掉最后一个存活对象以后的所有内存</li></ul></li><li><p>分代收集</p><ul><li>一般将Java堆分为新生代和老年代</li><li>新生代每次垃圾回收都有大量对象死去，只有少数存活，因此采用复制算法</li><li>老年代的对象存活率高，并且没有额外空间担保，就必须使用标记清除或者是标记整理</li></ul></li></ul><h3 id="集合框架，hashmap源码-扩容机制"><a href="#集合框架，hashmap源码-扩容机制" class="headerlink" title="集合框架，hashmap源码,扩容机制"></a>集合框架，hashmap源码,扩容机制</h3><h3 id="三次握手，四次挥手，两次握手是否可以建立连接"><a href="#三次握手，四次挥手，两次握手是否可以建立连接" class="headerlink" title="三次握手，四次挥手，两次握手是否可以建立连接"></a>三次握手，四次挥手，两次握手是否可以建立连接</h3><h3 id="MySQL索引，b＋树，最左前缀匹配，主从复制，聚簇索引和非聚簇索引"><a href="#MySQL索引，b＋树，最左前缀匹配，主从复制，聚簇索引和非聚簇索引" class="headerlink" title="MySQL索引，b＋树，最左前缀匹配，主从复制，聚簇索引和非聚簇索引"></a>MySQL索引，b＋树，最左前缀匹配，主从复制，聚簇索引和非聚簇索引</h3><h3 id="Redis-基本数据类型，缓存穿透，缓存雪崩，持久化，淘汰策略"><a href="#Redis-基本数据类型，缓存穿透，缓存雪崩，持久化，淘汰策略" class="headerlink" title="Redis 基本数据类型，缓存穿透，缓存雪崩，持久化，淘汰策略"></a>Redis 基本数据类型，缓存穿透，缓存雪崩，持久化，淘汰策略</h3><h3 id="设计模式，单例，代理和装饰器的区别，简单工厂和抽象工厂"><a href="#设计模式，单例，代理和装饰器的区别，简单工厂和抽象工厂" class="headerlink" title="设计模式，单例，代理和装饰器的区别，简单工厂和抽象工厂"></a>设计模式，单例，代理和装饰器的区别，简单工厂和抽象工厂</h3><h3 id="springcloud相关，hystrix实现原理"><a href="#springcloud相关，hystrix实现原理" class="headerlink" title="springcloud相关，hystrix实现原理"></a>springcloud相关，hystrix实现原理</h3><h3 id="如何实现限流，漏桶算法"><a href="#如何实现限流，漏桶算法" class="headerlink" title="如何实现限流，漏桶算法"></a>如何实现限流，漏桶算法</h3><h3 id="多线程，线程池的主要参数，线程池的种类"><a href="#多线程，线程池的主要参数，线程池的种类" class="headerlink" title="多线程，线程池的主要参数，线程池的种类"></a>多线程，线程池的主要参数，线程池的种类</h3><blockquote><p>这些题都是来源于身边朋友的分享</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;final-finally-finilize的区别&quot;&gt;&lt;a href=&quot;#final-finally-finilize的区别&quot; class=&quot;headerlink&quot; title=&quot;final finally finilize的区别&quot;&gt;&lt;/a&gt;final final
      
    
    </summary>
    
    
      <category term="面试集锦" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%9B%86%E9%94%A6/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="一面" scheme="http://yoursite.com/tags/%E4%B8%80%E9%9D%A2/"/>
    
  </entry>
  
</feed>
